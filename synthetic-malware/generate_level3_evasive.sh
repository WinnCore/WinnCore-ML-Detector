#!/bin/bash
set -e

OUTPUT_DIR="samples_level3_evasive"
mkdir -p "$OUTPUT_DIR"

echo "ðŸ”¥ Generating Level 3: EVASIVE MALWARE SAMPLES"
echo "=============================================="
echo ""
echo "These samples use advanced evasion techniques:"
echo "  âœ“ Polymorphic code (changes on each compile)"
echo "  âœ“ Metamorphic transformations"
echo "  âœ“ Low entropy (appears benign)"
echo "  âœ“ Minimal suspicious strings"
echo "  âœ“ Time-delayed execution"
echo "  âœ“ Environment checks"
echo "  âœ“ Code caves and padding"
echo "  âœ“ Legitimate-looking behavior"
echo ""

#==============================================================================
# CATEGORY 1: LOW ENTROPY MALWARE (100 samples)
# Challenge: High entropy is easy to detect, so we keep it LOW
#==============================================================================

echo "ðŸ“¦ Creating low-entropy evasive samples (1-100)..."

for i in $(seq 1 100); do
cat > /tmp/low_entropy_${i}.rs << EOF
// Low entropy malware - appears benign
fn main() {
    // Normal-looking string data (low entropy)
    let normal_strings = vec![
        "Welcome to the application",
        "Loading configuration file",
        "Initializing system components",
        "Processing user request",
        "Connecting to database",
    ];
    
    // Malicious functionality hidden in "normal" code
    let config_path = "/etc"; // Looks like config access
    let home = std::env::var("HOME").unwrap_or_default();
    
    // Slow, gradual behavior (time-delayed)
    for iteration in 0..$((i % 20 + 5)) {
        std::thread::sleep(std::time::Duration::from_millis($((i * 10))));
        
        // Looks like logging
        if iteration % 3 == 0 {
            let _ = std::fs::read_to_string("/proc/cpuinfo");
        }
    }
    
    // Benign-looking output
    println!("Operation completed successfully");
}
EOF
done

#==============================================================================
# CATEGORY 2: POLYMORPHIC VARIANTS (100 samples)
# Challenge: Same functionality, completely different code structure
#==============================================================================

echo "ðŸ“¦ Creating polymorphic variants (101-200)..."

for i in $(seq 101 200); do
variant=$((i % 5))

case $variant in
0) # Version A: Loop-based
cat > /tmp/poly_${i}.rs << EOF
fn main() {
    let mut data = Vec::new();
    for x in 0..$((i * 10)) {
        data.push((x * 17 + $i) % 256);
    }
    for chunk in data.chunks(16) {
        process_chunk(chunk);
    }
}
fn process_chunk(_: &[u8]) { }
EOF
;;

1) # Version B: Iterator-based (same logic, different structure)
cat > /tmp/poly_${i}.rs << EOF
fn main() {
    let data: Vec<u8> = (0..$((i * 10)))
        .map(|x| ((x * 17 + $i) % 256) as u8)
        .collect();
    data.chunks(16).for_each(|c| process_chunk(c));
}
fn process_chunk(_: &[u8]) { }
EOF
;;

2) # Version C: Functional style
cat > /tmp/poly_${i}.rs << EOF
fn main() {
    let result = generate_data($((i * 10)))
        .chunks(16)
        .map(|c| process_chunk(c))
        .count();
}
fn generate_data(n: usize) -> Vec<u8> {
    (0..n).map(|x| ((x * 17) % 256) as u8).collect()
}
fn process_chunk(_: &[u8]) -> u8 { 0 }
EOF
;;

3) # Version D: Recursive style
cat > /tmp/poly_${i}.rs << EOF
fn main() {
    process_recursive(0, $((i * 10)));
}
fn process_recursive(start: usize, end: usize) {
    if start >= end { return; }
    let _ = (start * 17) % 256;
    process_recursive(start + 1, end);
}
EOF
;;

4) # Version E: Struct-based
cat > /tmp/poly_${i}.rs << EOF
struct Processor { data: Vec<u8> }
impl Processor {
    fn new(size: usize) -> Self {
        Self { data: (0..size).map(|x| (x % 256) as u8).collect() }
    }
    fn process(&self) { 
        self.data.chunks(16).for_each(|_| {});
    }
}
fn main() {
    let p = Processor::new($((i * 10)));
    p.process();
}
EOF
;;
esac
done

#==============================================================================
# CATEGORY 3: BENIGN-LOOKING WITH HIDDEN PAYLOAD (100 samples)
# Challenge: Looks like a normal program, has malware behavior
#==============================================================================

echo "ðŸ“¦ Creating benign-looking samples (201-300)..."

for i in $(seq 201 300); do
cat > /tmp/benign_looking_${i}.rs << EOF
// Appears to be a simple file utility
use std::path::PathBuf;

fn list_directory(path: &str) -> Vec<PathBuf> {
    std::fs::read_dir(path)
        .ok()
        .map(|entries| {
            entries
                .filter_map(|e| e.ok())
                .map(|e| e.path())
                .collect()
        })
        .unwrap_or_default()
}

fn check_file_exists(path: &str) -> bool {
    std::path::Path::new(path).exists()
}

fn main() {
    // Normal-looking file operations
    let home = std::env::var("HOME").unwrap_or_default();
    
    // Looks like a file browser
    let paths = vec!["/usr/bin", "/etc"];
    for path in paths {
        if check_file_exists(path) {
            let _files = list_directory(path);
        }
    }
    
    // Hidden: environment inspection
    for i in 0..$((i % 20)) {
        std::env::var("USER").ok();
    }
    
    println!("File check complete");
}
EOF
done

#==============================================================================
# CATEGORY 4: METAMORPHIC (100 samples)
# Challenge: Code mutates, different instructions each time
#==============================================================================

echo "ðŸ“¦ Creating metamorphic samples (301-400)..."

for i in $(seq 301 400); do
# Each sample uses different control flow
junk_ops=$((i % 10 + 1))

cat > /tmp/meta_${i}.rs << EOF
fn main() {
    let seed = $i;
    
    // Junk operations (dead code that varies)
$(for j in $(seq 1 $junk_ops); do
    echo "    let _junk_$j = seed * $j + $((RANDOM % 100));"
done)
    
    // Real functionality hidden among junk
    match seed % 4 {
        0 => { 
            for _ in 0..10 { std::hint::black_box($i); }
        }
        1 => {
            let v: Vec<u8> = (0..10).map(|x| (x + seed) as u8).collect();
            std::hint::black_box(v);
        }
        2 => {
            fn inner() { std::thread::sleep(std::time::Duration::from_micros(1)); }
            inner();
        }
        _ => {
            let mut acc = 0;
            for i in 0..10 { acc += i; }
            std::hint::black_box(acc);
        }
    }
    
    println!("Checksum: {}", seed);
}
EOF
done

#==============================================================================
# CATEGORY 5: ADVANCED EVASION (100 samples)
# Challenge: Multiple evasion techniques combined
#==============================================================================

echo "ðŸ“¦ Creating advanced evasion samples (401-500)..."

for i in $(seq 401 500); do
cat > /tmp/advanced_${i}.rs << EOF
use std::time::{SystemTime, UNIX_EPOCH};

fn is_debugged() -> bool {
    // Timing-based debugger detection
    let start = std::time::Instant::now();
    let mut sum = 0u64;
    for j in 0..100 { sum = sum.wrapping_add(j); }
    start.elapsed().as_micros() > 1000
}

fn is_vm() -> bool {
    // Simple VM detection (checks CPU info)
    if let Ok(info) = std::fs::read_to_string("/proc/cpuinfo") {
        info.contains("hypervisor") || info.contains("QEMU")
    } else {
        false
    }
}

fn main() {
    // Early exit if debugger detected
    if is_debugged() { 
        println!("System check passed");
        return; 
    }
    
    // Early exit if VM detected
    if is_vm() {
        println!("Environment validated");
        return;
    }
    
    // Time-based trigger (only runs at certain times)
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    if now % $((i % 100 + 10)) != 0 {
        println!("Scheduled task not due");
        return;
    }
    
    // Low-entropy legitimate operations
    let config_dirs = vec!["/etc", "/usr/share"];
    for dir in config_dirs {
        if std::path::Path::new(dir).exists() {
            // Looks like config access
            std::fs::read_dir(dir).ok();
        }
    }
    
    println!("Configuration check completed");
}
EOF
done

#==============================================================================
# COMPILE EVERYTHING
#==============================================================================

echo ""
echo "ðŸ”¨ Compiling 500 Level 3 samples..."
echo "   (Optimized for small size + evasion)"
echo ""

compile_batch() {
    local start=$1
    local end=$2
    local prefix=$3
    
    for i in $(seq $start $end); do
        rustc -C opt-level=2 -C panic=abort -C strip=symbols \
            /tmp/${prefix}_${i}.rs -o "$OUTPUT_DIR/${prefix}_${i}" 2>/dev/null &
        
        if (( i % 20 == 0 )); then
            wait
            echo "  Compiled $((i - start + 1))/$((end - start + 1))..."
        fi
    done
    wait
}

echo "Compiling low-entropy samples..."
compile_batch 1 100 low_entropy

echo "Compiling polymorphic variants..."
compile_batch 101 200 poly

echo "Compiling benign-looking samples..."
compile_batch 201 300 benign_looking

echo "Compiling metamorphic samples..."
compile_batch 301 400 meta

echo "Compiling advanced evasion samples..."
compile_batch 401 500 advanced

# Cleanup
rm /tmp/low_entropy_*.rs /tmp/poly_*.rs /tmp/benign_looking_*.rs \
   /tmp/meta_*.rs /tmp/advanced_*.rs 2>/dev/null

echo ""
echo "âœ… LEVEL 3 COMPLETE!"
echo "Created $(ls -1 $OUTPUT_DIR | wc -l) evasive samples"
echo "Disk usage: $(du -sh $OUTPUT_DIR | cut -f1)"
echo ""
echo "ðŸŽ¯ Evasion techniques included:"
echo "   âœ“ Low entropy (harder to detect)"
echo "   âœ“ Polymorphic code (5 variants of same logic)"
echo "   âœ“ Benign appearance (looks like normal utilities)"
echo "   âœ“ Metamorphic (different instructions each compile)"
echo "   âœ“ Anti-debug + Anti-VM"
echo "   âœ“ Time-delayed triggers"
echo "   âœ“ Environment checks"
echo ""
echo "ðŸ§ª Test detection rate:"
echo "   cd ../extractor"
echo "   ./target/release/arm64_extractor --input ../synthetic-malware/samples_level3_evasive --output ../datasets/malicious_level3.jsonl --label 1 --source evasive"
echo ""
echo "ðŸ“Š Train new model:"
echo "   cd ../training"
echo "   python train_lightgbm_no_plots.py --features ../datasets/combined_all.jsonl --output ../models/gbm_v3_hardened.onnx --report ../eval/report_v3.md"
